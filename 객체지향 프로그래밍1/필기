객체지향 언어
- 코드의 재사용성이 높다.
- 코드의 관리가 용이하다.
- 신뢰성이 높은 프로그래밍을 가능하게 한다.
// 재사용성, 유지보수, 중복된 코드의 제거

클래스 : 객체를 정의해놓은 것(붕어빵 틀)
	└ 클래스는 객체를 생성하는데 사용된다.

객체 : 실제로 존재하는 것. 사물 or 개념(붕어빵)

인스턴스화 : 클래스로부터 객체를 만드는 과정
인스턴스 : 어떤 클래스로부터 만들어진 객체
Int num = new Int();

클래스의 속성 -> 변수
클래스의 기능 -> 함수(메서드)
											선언위치
	   ┌클래스변수 : static이 붙은 것(공유변수) 
멤버변수 │										클래스 영역	
	   └인스턴스변수 : static이 붙지 않은 것 
지역변수										클래스 이외의 영역(메서드, 생성자, 초기화 블럭 내부 등)


메서드(함수) : 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.
- 높은 재사용성
- 중복된 코드의 제거
- 프로그램의 구조화
					┌ 매개변수
- 반환타입 메서드명(타입 변수명, 타입 변수명, ...){		//선언부
		//메서드 호출 시 수행될 코드					//구현부
	}
  ex)     int add(int a, int b){
		  	int result = a + b;
		  	return result;
		  }
		  
- 반환타입 : 메서드 작업수행 결과(출력)인 반환값의 타입을 적는다. 반환값이 없으면 void를 적는다.
- return : 반환타입이 void가 아닌 경우, 구현부 {} 안에 'return 반환값'이 반드시 포함되어야 한다.

- 지역변수 : int add(x, y) 메서드와 int sub(x, y)의 메서드는 이름은 같아도 서로 다른 변수이다. (지역변수)
  

- JVM의 메모리 구조 : 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고
				   JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
				   그중 주요 영역 3개는 메서드 영역(method area), 힙(heap), 호출스택(call stack)이다.
				    
 1) 메서드 영역 : 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 클래스 데이터를 메서드 영역에 저장한다.
 				-> 클래스변수(cv)가 메서드 영역에 생성된다.
 2) 힙 : 인스턴스(iv)가 생성되는 공간이다.
 3) 호출스택 : 메서드의 작업에 필요한 메모리 공간을 제공한다. 
 			 메서드가 호출되면 메서드가 작업을 수행하는 동안 지역변수(lv)들과 연산의 중간결과 등을 저장하는데 사용된다.
 			 그리고 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다. 			
   - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
   - 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
   - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
   - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
   
   
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다. (read Only)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다. (read & write) 

- 클래스 메서드(static 메서드) : 객체를 생성하지 않고도 호출 가능
- 인스턴스 메서드 : 반드시 객체를 생성해야만 호출 가능

 - 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
 - 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
 - 클래스 메서드는 인스턴스 변수를 사용할 수 없다. (인스턴스 메서드는 static 변수 사용 가능)
 - 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
- 반환타입이 참조형인 경우 : 메서드가 '객체의 주소'를 반환한다는 것이다.


- 재귀호출 : 메서드의 내부에서 메서드 자신을 다시 호출하는 것 (재귀 메서드)
 -> 재귀호출은 시간적으로는 비효율적이지만, 논리적으로 간결해진다는 장점이 있다. (상황에 따라 잘 판단하고 써야 한다.)
 
 - 대표적인 재귀호출은 팩토리얼이다.
	   		
	   		
	   		
- 오버로딩 : 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것이다.
		   하나의 메서드 이름으로 여러 기능을 구현하는 것.
    └ 조건 1) 메서드 이름이 같아야 한다.
    	  2) 매개변수의 개수 또는 타입이 달라야 한다.
   	└ 장점 : 메서드의 이름만 보고 기능을 추측하거나 오류의 가능성을 줄일 수 있고, 작명 고민을 덜 수 있다.
   	
- 가변인자 오버로딩 : 메서드의 매개변수 개수를 동적으로 지정해줄 수 있는 기능을 '가변인자'라고 한다.


- 생성자 : 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
		  -> 인스턴스 변수의 초기화 작업에 주로 사용, 인스턴스 생성 시 실행되어야 할 작업을 위해 사용
	└ 생성자의 이름은 클래스의 이름과 같아야 한다.
	  생성자는 return값이 없다.
	  생성자도 오버로딩 가능 -> 매개변수가 없는 생성자 / 매개변수가 있는 생성자
- 기본 생성자 : 컴파일할 때 생성자가 하나도 정의되어 있지 않으면, 컴파일러는 자동적으로 기본생성자를 추가한다.
			  기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때이다.
			  
- this(), this
  - 생성자에서 다른 생성자 호출하기(생성자 간에 서로 호출하기)
  - 생성자의 이름으로 클래스이름 대신 this를 사용한다.
  - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
  
  
- 변수의 초기화 : 변수를 선언하고 처음으로 값을 저장하는 것이며, 해주는 것이 바람직하다.
    └ 멤버변수(클래스변수, 인스턴스변수) : 초기화를 하지 않아도 자동적으로 기본값으로 초기화된다.
    └ 지역변수 : 사용하기 전에 반드시 초기화해야 한다.
    
- 멤버변수의 초기화 방법
	└ 명시적 초기화 : 변수를 선언과 동시에 초기화하는 것.
	└ 생성자
	└ 초기화 블럭 
		1) 클래스 초기화 블럭
		2) 인스턴스 초기화 블럭      			     		   		